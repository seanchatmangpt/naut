{
    "sourceFile": "generate_synthetic_orderbook.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1749259675684,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1749259687247,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,9 @@\n from datetime import datetime, timedelta\n import random\n from pathlib import Path\n from typing import List, Tuple\n+import pytz\n \n class SyntheticOrderBookGenerator:\n     def __init__(\n         self,\n@@ -22,9 +23,9 @@\n         self.volatility = volatility\n         self.num_levels = num_levels\n         self.base_volume = base_volume\n         self.update_frequency_ms = update_frequency_ms\n-        self.start_time = start_time or datetime(2022, 11, 1, tzinfo=pd.UTC)\n+        self.start_time = start_time or datetime(2022, 11, 1, tzinfo=pytz.UTC)\n         self.end_time = self.start_time + timedelta(hours=duration_hours)\n         \n         # Initialize order book state\n         self.current_price = start_price\n@@ -148,9 +149,9 @@\n         volatility=0.02,\n         num_levels=20,\n         base_volume=1.0,\n         update_frequency_ms=100,\n-        start_time=datetime(2022, 11, 1, tzinfo=pd.UTC),\n+        start_time=datetime(2022, 11, 1, tzinfo=pytz.UTC),\n         duration_hours=24,\n     )\n     \n     generator.generate_data(data_dir) \n\\ No newline at end of file\n"
                }
            ],
            "date": 1749259675684,
            "name": "Commit-0",
            "content": "import numpy as np\nimport pandas as pd\nfrom datetime import datetime, timedelta\nimport random\nfrom pathlib import Path\nfrom typing import List, Tuple\n\nclass SyntheticOrderBookGenerator:\n    def __init__(\n        self,\n        symbol: str = \"BTCUSDT\",\n        start_price: float = 20000.0,\n        volatility: float = 0.02,\n        num_levels: int = 20,\n        base_volume: float = 1.0,\n        update_frequency_ms: int = 100,\n        start_time: datetime = None,\n        duration_hours: int = 24,\n    ):\n        self.symbol = symbol\n        self.start_price = start_price\n        self.volatility = volatility\n        self.num_levels = num_levels\n        self.base_volume = base_volume\n        self.update_frequency_ms = update_frequency_ms\n        self.start_time = start_time or datetime(2022, 11, 1, tzinfo=pd.UTC)\n        self.end_time = self.start_time + timedelta(hours=duration_hours)\n        \n        # Initialize order book state\n        self.current_price = start_price\n        self.bids: List[Tuple[float, float]] = []  # (price, quantity)\n        self.asks: List[Tuple[float, float]] = []  # (price, quantity)\n        \n    def _generate_level_volumes(self, is_bid: bool) -> List[float]:\n        \"\"\"Generate realistic volume distribution for order book levels.\"\"\"\n        volumes = []\n        for i in range(self.num_levels):\n            # Exponential decay of volumes as we move away from mid price\n            decay = np.exp(-0.5 * i)\n            # Add some randomness\n            volume = self.base_volume * decay * (0.8 + 0.4 * random.random())\n            volumes.append(volume)\n        return volumes\n\n    def _generate_snapshot(self) -> pd.DataFrame:\n        \"\"\"Generate initial order book snapshot.\"\"\"\n        # Generate bid prices (below current price)\n        bid_prices = [self.current_price * (1 - 0.0001 * i) for i in range(1, self.num_levels + 1)]\n        bid_volumes = self._generate_level_volumes(is_bid=True)\n        \n        # Generate ask prices (above current price)\n        ask_prices = [self.current_price * (1 + 0.0001 * i) for i in range(1, self.num_levels + 1)]\n        ask_volumes = self._generate_level_volumes(is_bid=False)\n        \n        # Create snapshot data\n        data = []\n        timestamp = int(self.start_time.timestamp() * 1000)\n        \n        # Add bids\n        for price, volume in zip(bid_prices, bid_volumes):\n            data.append({\n                'timestamp': timestamp,\n                'symbol': self.symbol,\n                'side': 'bids',\n                'price': price,\n                'quantity': volume,\n                'update_id': 0,\n            })\n            \n        # Add asks\n        for price, volume in zip(ask_prices, ask_volumes):\n            data.append({\n                'timestamp': timestamp,\n                'symbol': self.symbol,\n                'side': 'asks',\n                'price': price,\n                'quantity': volume,\n                'update_id': 0,\n            })\n            \n        return pd.DataFrame(data)\n\n    def _generate_updates(self) -> pd.DataFrame:\n        \"\"\"Generate order book updates.\"\"\"\n        data = []\n        current_time = self.start_time\n        update_id = 1\n        \n        while current_time < self.end_time:\n            # Random walk for price\n            price_change = self.current_price * self.volatility * np.random.normal(0, 1) * np.sqrt(self.update_frequency_ms / 1000)\n            self.current_price += price_change\n            \n            # Decide if we're updating bids or asks\n            side = random.choice(['bids', 'asks'])\n            \n            # Generate new price and quantity\n            if side == 'bids':\n                price = self.current_price * (1 - 0.0001 * random.randint(1, self.num_levels))\n            else:\n                price = self.current_price * (1 + 0.0001 * random.randint(1, self.num_levels))\n                \n            quantity = self.base_volume * random.random()\n            \n            # Randomly decide if this is an update or deletion\n            if random.random() < 0.1:  # 10% chance of deletion\n                quantity = 0\n                \n            data.append({\n                'timestamp': int(current_time.timestamp() * 1000),\n                'symbol': self.symbol,\n                'side': side,\n                'price': price,\n                'quantity': quantity,\n                'update_id': update_id,\n            })\n            \n            current_time += timedelta(milliseconds=self.update_frequency_ms)\n            update_id += 1\n            \n        return pd.DataFrame(data)\n\n    def generate_data(self, output_dir: str = \"data\"):\n        \"\"\"Generate and save both snapshot and update files.\"\"\"\n        output_path = Path(output_dir) / \"Binance\"\n        output_path.mkdir(parents=True, exist_ok=True)\n        \n        # Generate and save snapshot\n        snapshot_df = self._generate_snapshot()\n        snapshot_file = output_path / f\"{self.symbol}_T_DEPTH_{self.start_time.strftime('%Y-%m-%d')}_depth_snap.csv\"\n        snapshot_df.to_csv(snapshot_file, index=False)\n        print(f\"Generated snapshot file: {snapshot_file}\")\n        \n        # Generate and save updates\n        updates_df = self._generate_updates()\n        updates_file = output_path / f\"{self.symbol}_T_DEPTH_{self.start_time.strftime('%Y-%m-%d')}_depth_update.csv\"\n        updates_df.to_csv(updates_file, index=False)\n        print(f\"Generated updates file: {updates_file}\")\n\nif __name__ == \"__main__\":\n    # Create data directory in user's home directory\n    data_dir = str(Path.home() / \"Downloads\" / \"Data\")\n    \n    # Generate synthetic data\n    generator = SyntheticOrderBookGenerator(\n        symbol=\"BTCUSDT\",\n        start_price=20000.0,\n        volatility=0.02,\n        num_levels=20,\n        base_volume=1.0,\n        update_frequency_ms=100,\n        start_time=datetime(2022, 11, 1, tzinfo=pd.UTC),\n        duration_hours=24,\n    )\n    \n    generator.generate_data(data_dir) "
        }
    ]
}